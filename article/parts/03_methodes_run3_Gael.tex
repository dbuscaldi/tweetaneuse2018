 Notre troisième système utilise également une approche d'analyse au grain caractère. Plus exactement cette approche se situe à la lisière entre l'algorithmique du texte et la fouille de données.
 Nous utilisons des motifs (en caractères) fermés et fréquents comme traits pour entraîner un classifieur.

 Les propriétés de fermeture et de fréquence sont définis de la façon suivante :%\footnote{Il s'agit d'une transposition de \textit{frequency}, il s'agit donc d'effectif}
\begin{description}
\item[Fermeture]: le motif ne peut être étendu vers la gauche ou vers la droite sans diminuer son nombre d'occurences
\item[Fréquence]: le motif respecte une borne minimale de nombre d'apparitions
\end{description}

 Pour calculer des motifs en caractères de manière efficace, en l'occurrence avec une complexité linéaire en la taille des données, nous utilisons ici une implantation en Python de l'algorithme de Ukkonen \cite{Ukkonen-2009} exploitant les tableaux de suffixes augmentés décrits par Juha Kärkkainen (\cite{Karkka-2006}).
 \cite{Buscaldi-2017} rappelent que les propriétés de fermeture et de fréquence correspondent en algorithmique du texte aux propriétés de maximalité et de répétition.
 Cette technique peut être décrite comme une tokenization "non-supervisée" en ce sens que les règles de découpage ne sont pas pré-définies mais sont calculées en fonction du corpus donné en entrée. %  Les motifs d'effectif 1 ne sont pas exploités
 
 De façon traditionnelle en fouille de données, un défi important est de limiter l'explosion du nombre de motifs, que ce soit pour des raisons calculatoires ou pour des raisons de lisibilité des résultats.% En effet, nous pouvons voir dans le tableau \ref{tab:nbMotifs} que le nombre de motifs peut être très important.
 Un filtrage classique consiste à appliquer aux motifs deux types de contraintes:
\begin{itemize}
  \item La contrainte de support par laquelle on définit le nombre minimal ($minsup$) et maximal ($maxsup$) d'objets qui supportent un motif. Ici cela consiste à définir le nombre minimal et maximal de tweets dans lequel le motif apparaît.
  \item La contrainte de longueur par laquelle on définit la longueur minimale ($minlen$) et maximale ($maxlen$) d'un motif. Ici, il s'agit d'une longueur en caractères.
\end{itemize}

 Notre chaîne de traitement est définie comme suit:
\begin{enumerate}
  \item Calcul des motifs fermés fréquents dans tout le corpus de tweets (train+test)
  \item Filtrage des motifs selon la longueur
  \item Filtrage des motifs selon le support
  \item Représentation de chaque tweet sous forme d'un vecteur d'effectif des motifs
  \item Utilisation de l'implantation de \textsc{SciKit} du SVM \textsc{One VS Rest}
\end{enumerate}

 
Durant la phase d'entraînement nous testé la méthode au travers d'un validation croisée en 10 strates au moyen de la fonction \textsc{StratifiedKFold} de \textsc{SciKit}\footnote{\url{http://scikit-learn.org/}}.
 En examinant les résultats, nous avons observé que la qualité des résultats n'augmentait plus au delà d'un seuil de $maxlen$ de 5.
Nous avons également remarqué, ce qui est conforme à des résultats précédents sur des données comparables (\cite{Buscaldi-2017}), que l'application de contraintes de support avait assez peu d'influence sur les résultats.
 Nous avons donc choisi de ne pas chercher à paramétrer finement cette contrainte.
 Toutefois, il est à noter que la réduction de l'espace de description engendrée par cette contrainte permet de diminuer le coût en calcul.

 Les résultats que nous avons soumis pour la phase de test ont été obtenus avec les configurations suivantes :
\begin{itemize}
  \item Pas de taille minimale ($minlen=1$)
  \item Pour la tâche 1 $maxlen=2$ et pour la tâche 2 $maxlen=3$
  \item Pas de contrainte de support
  \item Utilisation d'un noyau linéaire
\end{itemize}

 La configuration ci-dessus s'est avérée la plus efficace sur les données d'entraînement et la plus fiable pour effectuer les calculs dans le temps imparti. L'utilisation d'un noyau radial permettait toutefois d'obtenir de bons résultats y compris en se contentant de smotifs de taille 1 ($maxlen=1$).

 
